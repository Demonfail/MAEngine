#include <MAE/FMOD/CFmod.h>

uint CFmod::DSPCreate(uint type) {
	FMOD::DSP *dsp;

	if (m_vDSP.size() + 1 > m_iMaxDSPs) {
		return 0; //Handle errors better here, maybe an sint so we can return negative numbers?
	}

	FMOD_DSP_DESCRIPTION DSPTYPE[28]{
		FMOD_DSP_TYPE_CHANNELMIX,
		FMOD_DSP_TYPE_CHORUS,
		FMOD_DSP_TYPE_COMPRESSOR,
		FMOD_DSP_TYPE_CONVOLUTIONREVERB,
		FMOD_DSP_TYPE_DELAY,
		FMOD_DSP_TYPE_DISTORTION,
		FMOD_DSP_TYPE_ECHO,
		FMOD_DSP_TYPE_ENVELOPEFOLLOWER,
		FMOD_DSP_TYPE_FADER,
		FMOD_DSP_TYPE_FLANGE,
		FMOD_DSP_TYPE_HIGHPASS,
		FMOD_DSP_TYPE_HIGHPASS_SIMPLE,
		FMOD_DSP_TYPE_ITECHO,
		FMOD_DSP_TYPE_ITLOWPASS,
		FMOD_DSP_TYPE_LIMITER,
		FMOD_DSP_TYPE_LOWPASS,
		FMOD_DSP_TYPE_LOWPASS_SIMPLE,
		FMOD_DSP_TYPE_MAX,
		FMOD_DSP_TYPE_MIXER,
		FMOD_DSP_TYPE_NORMALIZE,
		FMOD_DSP_TYPE_OBJECTPAN,
		FMOD_DSP_TYPE_PAN,
		FMOD_DSP_TYPE_PARAMEQ,
		FMOD_DSP_TYPE_PITCHSHIFT,
		FMOD_DSP_TYPE_SFXREVERB,
		FMOD_DSP_TYPE_THREE_EQ,
		FMOD_DSP_TYPE_TRANSCEIVER,
		FMOD_DSP_TYPE_TREMOLO
	};

	m_pSystem->createDSP(&DSPTYPE[type], &dsp);
	m_vDSP.push_back(dsp);
	return m_vDSP.size() - 1;
}

void CFmod::DSPActivate(uint DSPIndex, bool state) {
	m_vDSP[DSPIndex]->setActive(state);
}

void CFmod::DSPDestroy(uint DSPIndex) {
	m_vDSP[DSPIndex]->disconnectAll(true, true);
	m_vDSP[DSPIndex]->release();
}